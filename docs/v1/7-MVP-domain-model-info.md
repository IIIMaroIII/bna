- Что такое MVP Domain Model

        **MVP Domain Model** — это описание “предметной области” твоего MVP в виде:
        - **сущностей** (что существует в системе)
        - **связей** между ними (как они относятся друг к другу)
        - **правил** (что разрешено/запрещено)

        Проще:
        > это “скелет данных и логики”, на котором держатся UI, API и БД.

        Пример в твоём проекте:
        - Company, User, Team, Project, WorkSession
        - кто к чему привязан
        - какие ограничения (1 активная сессия, доступ к проектам через команду и т.д.)

- Что такое артефакты
    - **Артефакты** — это конкретные “результаты работы”, которые остаются после этапа.  
        То, что можно:
        - сохранить в Notion/Google Doc
        - отдать команде
        - использовать как основу для разработки
- Цель доменной модели
    - Зафиксировать **что хранится**, **как связано** и **какие правила нельзя нарушать**, чтобы:
        - бэкенд/фронт/дизайн говорили на одном языке
        - было понятно, какие API нужны
        - не появлялись противоречия в данных

- Артефакты этого шага (что у вас “останется на руках”)
    1) **MVP Domain Model** — сущности, поля, связи, правила  
    2) **Invariants / Constraints** — список запретов и обязательных условий (то, что должно быть enforced)  
    3) **Glossary** — единые термины (Company, Team, Project, WorkSession, Active Session)  
    4) (следующий шаг) **API Contract draft** — endpoints под UI Map


## 1) Entities (что существует)
**Цель:** составить список объектов, которые система должна хранить.

### Как определить Entity (3 вопроса)
1) Нужно ли это хранить дольше одного действия?  
2) Есть ли у этого свои поля?  
3) Есть ли связи/ссылки с другими объектами?

✅ Да на все → Entity.

**Выход:** список сущностей + минимальные поля (`id`, ключевые атрибуты, статусы, даты).

---

## 2) Relations (как связано)
**Цель:** зафиксировать, как сущности связаны между собой.

### Как определить связь
- Если A должен “знать” B → нужна ссылка (`*_id`)
- Если это **1→N**: foreign key на стороне N  
- Если это **N↔N**: отдельная сущность-связка (join entity)

**Выход:** кардинальности:
- 1 → N (one-to-many) 
- N ↔ N (many to many) (через join)`

---

## 3) Rules (что нельзя нарушать)
**Цель:** зафиксировать бизнес-ограничения, которые держат данные в порядке.

### Как определить правило
- Берёшь ключевые сценарии (clock-in, назначение на проект)
- Выписываешь проверки “что должно быть истинно”
- Формулируешь запреты/обязательные условия

**Выход:** список инвариантов/constraints:
- доступы (RBAC, company isolation)
- статусы (active/inactive)
- уникальности (1 активная сессия, 1 активная команда)
- запреты действий (clock-in без team/project/wifi)

---

## Мини-цепочка работы
1) Entities: “что хранить”
2) Relations: “как это связано”
3) Rules: “какие условия enforce’ить”

### ================================= MVP Domain Model =================================
